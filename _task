Расчёт просадки (план создания фичи):

1. Функция по выгрузке и сохранению тиковых данных.
 -- взять за основу текущий стандартизированный формат.
 -- догружать ещё не достающие данные, т.е. если есть только за 25й, а надо 13 сентября 24го, то догружать все данные с сентября 24го года..
 -- различать данные по серверам и символам.
 -- Применить чтение тиков из tkc-файлов при помощи библиотеки mt5tickreader...
 -- Применить чтение тиков из терминала при помощи библиотеки MetaTrader5..
 

2. Функция которая принимает на вход символ, размер лота, цену, и возвращает размер маржи.

3. Функция которая принимает на вход символ, размер лота, цену входа с направлением и цену для расчётов.
И по этим данным возвращает расчёт локальной просадки/прибыли.

4. Функция которая принимает на вход символ, размер лота, цену с направлением входа и время IN/OUT. Находит по тиковым данным цены HIGH/LOW в этом промежутке.

5. Функция которая принимает группу однонаправленных позиций с единым символом, и считает для неё общий уровень входа.

6. Функция которая получает пул позиций открытых в произвольном направлении и на произвольных символах. И временные рамки актуальные для этого пула (Время IN/OUT)...
	Разбивает все позиции на подгруппы по символам, а если позиции символа разнонаправленные, то ещё и на подгруппы по направлениям Buy/Sell..
	Рассчитывает для каждой подгруппы уровень входа при помощи функции-5, HIGH/LOW в тиках с помощью 4й функцией, максимальную просадку Эквити при помощи 3й, Маржу при помощи 2й..
	Если есть подгруппы в одном символе но в разных направлениях, то для них рассчитываются обобщающие данные Для маржи и просадки по эквити. Где Маржа будет равной той которая наибольшая в одной из подгрупп, а просадка это разница вычитаемая из большей величины.
	Суммирует значения маржи и просадки по всем символам... где в случае разнонаправленных позиций по символу принимаются только обобщённые. и полученные значения общей для всего пула маржи и просадки возвращаются обратно.
	
7. Функция которая принимает условия для выборки Время IN/OUT и Мэджики(или группы мэджиков)... Получает данные на начало среза, фактический Баланс депозита(при помощи уже реализованной функции), пул открытых позиций. Данные на конец среза, пул открытых позиций. Отбирает не агрегированные данные по сделкам совершаемым в этих временных рамках и соответствующих мэджиков (но надо иметь ввиду, что порой позиция открытая одним из мэджиков иногда закрывается с нулевым мэджиком, тогда их надо связывать через общий Position_ID и тоже учитывать).  В итоге получится серия временных промежутков где пул позиций неизменен... И в итоге функция будет возвращать пул позиций на начало, все промежуточные и в последней точке. Каждый элемент серии будет иметь три значения Пул позиций, Актуальное время IN/OUT.. Где в пуле позиций каждый элемент будет иметь значение Символа, направления Sell or Buy, размер позиции и цена открытия.

8. Функция которая получая данные из 7й функции прогоняет каждый пул по очереди через 6ю функцию и обогащает по нему данные, так что теперь там не только пул и актуальное время (IN/OUT), но и маржа и максимальная просадка.


PS. В табе Carts (Balance Change Chart)... также будет выбор разных мэджиков(или групп), включая кнопки ShowAll/HideAll/Refresh... И будет выводиться таблица с изменениями баланса, пула позиций, маржи, макс.просадки по эквити и акуальном для этих данных временом отрезке...

Уже есть такие вот куски из каких-то предыдущих работ, Возможно там уже есть нужные решения или частично:
```
def calculate_aggregate(pos):
    long_vol = sum(p['volume'] for p in pos.values() if p['type'] == mt5.ORDER_TYPE_BUY)
    short_vol = sum(p['volume'] for p in pos.values() if p['type'] == mt5.ORDER_TYPE_SELL)
    long_price = sum(p['price_open']*p['volume'] for p in pos.values() if p['type'] == mt5.ORDER_TYPE_BUY) / long_vol if long_vol else 0
    short_price = sum(p['price_open']*p['volume'] for p in pos.values() if p['type'] == mt5.ORDER_TYPE_SELL) / short_vol if short_vol else 0
    return long_vol, short_vol, long_price, short_price


def calculate_margin(symbol, volume, price):
    if volume == 0:
        return 0
    order_type = mt5.ORDER_TYPE_BUY if volume > 0 else mt5.ORDER_TYPE_SELL
    price = price or (mt5.symbol_info_tick(symbol).ask if order_type == mt5.ORDER_TYPE_BUY 
                     else mt5.symbol_info_tick(symbol).bid)
    return mt5.order_calc_margin(order_type, symbol, abs(volume), price)

	
def calculate_profit(symbol, volume, price_open, order_type, price_aim):
    """
    Рассчитывает прибыль/убыток для позиции при достижении целевой цены без использования MetaTrader5.

    Параметры:
    - symbol (str): Символ инструмента, например 'EURUSD' или 'XAUUSD'.
    - volume (float): Объём позиции в лотах (например, 0.1).
    - price_open (float): Цена открытия позиции.
    - order_type (int): Тип ордера (0 для покупки BUY, 1 для продажи SELL).
    - price_aim (float): Целевая цена для расчёта прибыли/убытка.

    Возвращает:
    - float: Прибыль/убыток в валюте депозита (предполагается USD). Положительное значение - прибыль, отрицательное - убыток.
    - None: Если символ не поддерживается или произошла ошибка.

    Примечания:
    - Функция использует предопределённые спецификации для популярных символов (на основе стандартных контрактов брокеров вроде Tickmill или MetaQuotes).
    - Для forex (например, EURUSD): 1 лот = 100000 единиц базовой валюты, tick_value = 1.0 USD за point (0.00001), pip (0.0001) = 10 USD.
    - Для XAUUSD: 1 лот = 100 унций, tick_value = 1.0 USD за point (0.01).
    - Предполагается, что валюта счёта - USD, и нет конверсии (для cross-пар это приближение).
    - Для точных расчётов используйте API брокера или MT5, так как спецификации могут варьироваться.
    - Добавьте свои символы в SPECS_DICT, если нужно.
    """

    # Словарь спецификаций символов (point - минимальное изменение цены, tick_value - стоимость изменения на point за 1 лот)
    SPECS_DICT = {
        'EURUSD': {'point': 0.00001, 'tick_value': 1.0},  # Для 5-digit: profit per point = 1 USD/lot
        'GBPUSD': {'point': 0.00001, 'tick_value': 1.0},
        'USDJPY': {'point': 0.001, 'tick_value': 1000 / 150},  # Пример: ~6.67 USD (нужна конверсия, здесь приближение на rate~150)
        'XAUUSD': {'point': 0.01, 'tick_value': 1.0},      # Gold: 1 USD per 0.01 move per lot
        # Добавьте другие: 'BTCUSD': {'point': 0.01, 'tick_value': 0.01}, etc.
    }

    specs = SPECS_DICT.get(symbol.upper())
    if not specs:
        print(f"Ошибка: Символ {symbol} не поддерживается. Добавьте в SPECS_DICT.")
        return None

    point = specs['point']
    tick_value = specs['tick_value']

    # Расчёт разницы в цене
    if order_type == 0:  # BUY
        price_diff = price_aim - price_open
    elif order_type == 1:  # SELL
        price_diff = price_open - price_aim
    else:
        print("Ошибка: order_type должен быть 0 (BUY) или 1 (SELL).")
        return None

    # Количество поинтов
    points = price_diff / point

    # Прибыль/убыток
    profit = points * tick_value * volume

    return profit

```